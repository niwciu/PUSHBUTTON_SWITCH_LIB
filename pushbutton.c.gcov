        -:    0:Source:D:/EMBEDDED/LIBRARIES/C_libraries/PUSHBUTTON_SWITCH_LIB/src/PUSHBUTTON/pushbutton.c
        -:    0:Graph:D:\EMBEDDED\LIBRARIES\C_libraries\PUSHBUTTON_SWITCH_LIB\test\pushbutton\out\CMakeFiles\pushbutton_test.dir\D_\EMBEDDED\LIBRARIES\C_libraries\PUSHBUTTON_SWITCH_LIB\src\PUSHBUTTON\pushbutton.c.gcno
        -:    0:Data:D:\EMBEDDED\LIBRARIES\C_libraries\PUSHBUTTON_SWITCH_LIB\test\pushbutton\out\CMakeFiles\pushbutton_test.dir\D_\EMBEDDED\LIBRARIES\C_libraries\PUSHBUTTON_SWITCH_LIB\src\PUSHBUTTON\pushbutton.c.gcda
        -:    0:Runs:2
        -:    1:/**
        -:    2: * @file pushbutton.c
        -:    3: * @author niwciu (niwciu@gmail.com)
        -:    4: * @brief This file contains the implementation of a pushbutton switch interface with debouncing and repetition
        -:    5: * functionality.
        -:    6: * @date 2024-02-26
        -:    7: *
        -:    8: * @copyright Copyright (c) 2024
        -:    9: *
        -:   10: */
        -:   11:#include "pushbutton.h"
        -:   12:#include <stddef.h>
        -:   13:// #include <stdio.h>  // to tylko do printfa
        -:   14:
        -:   15:static void update_pushbutton_input_state(PUSHBUTTON_TypDef *BUTTON);
        -:   16:static void update_button_deb_rep_counter(PUSHBUTTON_TypDef *BUTTON);
        -:   17:static void debounce_pushbutton_push_state(PUSHBUTTON_TypDef *BUTTON);
        -:   18:static void debounce_pushbutton_release_state(PUSHBUTTON_TypDef *BUTTON);
        -:   19:static void debounce_pushbutton_short_push_long_push_state(PUSHBUTTON_TypDef *BUTTON);
        -:   20:
        -:   21:static void handle_push_debouncing(PUSHBUTTON_TypDef *BUTTON);
        -:   22:static void handle_long_push_no_repetition_phase(PUSHBUTTON_TypDef *BUTTON);
        -:   23:static void handle_long_push_phase(PUSHBUTTON_TypDef *BUTTON);
        -:   24:static void handle_short_push_phase(PUSHBUTTON_TypDef *BUTTON);
        -:   25:static void handle_short_push_phase_pin_pushed(PUSHBUTTON_TypDef *BUTTON);
        -:   26:static void handle_short_push_phase_pin_released(PUSHBUTTON_TypDef *BUTTON);
        -:   27:
        -:   28:static void execute_push_callback(PUSHBUTTON_TypDef *BUTTON);
        -:   29:static void execute_release_callback(PUSHBUTTON_TypDef *BUTTON);
        -:   30:
     3534:   31:static void update_pushbutton_input_state(PUSHBUTTON_TypDef *BUTTON)
        -:   32:{
     3534:   33:    BUTTON->input_state = BUTTON->GPIO_interface->get_button_input_state();
     3534:   33-block  0
     3534:   34:}
        -:   35:
       36:   36:static void update_button_deb_rep_counter(PUSHBUTTON_TypDef *BUTTON)
        -:   37:{
        -:   38:
       36:   39:    if ((BUTTON->repetition) == REPETITION_ON)
       36:   39-block  0
        -:   40:    {
       30:   41:        if ((BUTTON->REPETITION_STATUS_FLAG) == REPETITION_INACTIVE)
       30:   41-block  0
        -:   42:        {
       12:   43:            BUTTON->deb_rep_timer = PUSHBUTTON_FIRST_REPETITION_TIME;
       12:   44:            BUTTON->REPETITION_STATUS_FLAG = REPETITION_ACTIVE;
       12:   44-block  0
        -:   45:        }
        -:   46:        else
        -:   47:        {
       18:   48:            BUTTON->deb_rep_timer = PUSHBUTTON_CONTINUOUS_REPETITION_TIME;
       18:   48-block  0
        -:   49:        }
        -:   50:    }
        -:   51:    else
        -:   52:    {
        6:   53:        BUTTON->deb_rep_timer = 0;
        6:   53-block  0
        -:   54:    }
       36:   55:}
        -:   56:
      540:   57:static void debounce_pushbutton_push_state(PUSHBUTTON_TypDef *BUTTON)
        -:   58:{
      540:   59:    if ((BUTTON->input_state) == PUSHED)
      540:   59-block  0
        -:   60:    {
      320:   61:        if ((BUTTON->deb_rep_timer) == 1)
      320:   61-block  0
        -:   62:        {
       36:   63:            execute_push_callback(BUTTON);
       36:   63-block  0
       36:   64:            update_button_deb_rep_counter(BUTTON);
        -:   65:        }
        -:   66:        else
        -:   67:        {
        -:   68:            // Empty else statement for case when deb_rep_timer is different then 1
        -:   69:        }
        -:   70:    }
        -:   71:    else
        -:   72:    {
      220:   73:        BUTTON->deb_rep_timer = PUSHBUTTON_DEBOUNCE_TIME;
      220:   74:        BUTTON->REPETITION_STATUS_FLAG = REPETITION_INACTIVE;
      220:   74-block  0
        -:   75:    }
      540:   76:}
        -:   77:
      474:   78:static void debounce_pushbutton_release_state(PUSHBUTTON_TypDef *BUTTON)
        -:   79:{
      474:   80:    if ((BUTTON->input_state) == PUSHED)
      474:   80-block  0
        -:   81:    {
      230:   82:        BUTTON->deb_rep_timer = PUSHBUTTON_DEBOUNCE_TIME;
      230:   82-block  0
        -:   83:    }
        -:   84:    else
        -:   85:    {
      244:   86:        if ((BUTTON->deb_rep_timer) == 1)
      244:   86-block  0
        -:   87:        {
        6:   88:            execute_release_callback(BUTTON);
        6:   88-block  0
        6:   89:            BUTTON->deb_rep_timer = 0;
        -:   90:        }
        -:   91:        else
        -:   92:        {
        -:   93:            // Empty else statement for case when deb_rep_timer is different then 1
        -:   94:        }
        -:   95:    }
      474:   96:}
        -:   97:
     2520:   98:void debounce_pushbutton_short_push_long_push_state(PUSHBUTTON_TypDef *BUTTON)
        -:   99:{
     2520:  100:    switch (BUTTON->pushbutton_state_machine)
     2520:  100-block  0
        -:  101:    {
     1248:  102:    case BUTTON_RELEASED:
     1248:  103:        if ((BUTTON->input_state) == PUSHED)
     1248:  103-block  0
        -:  104:        {
      396:  105:            BUTTON->pushbutton_state_machine = PUSH_DEBOUNCING;
      396:  106:            BUTTON->deb_rep_timer = PUSHBUTTON_DEBOUNCE_TIME;
      396:  106-block  0
        -:  107:        }
     1248:  108:        break;
     1248:  108-block  0
     1008:  109:    case PUSH_DEBOUNCING:
     1008:  110:        handle_push_debouncing(BUTTON);
     1008:  110-block  0
     1008:  111:        break;
      168:  112:    case SHORT_PUSH_PHASE:
      168:  113:        handle_short_push_phase(BUTTON);
      168:  113-block  0
      168:  114:        break;
       48:  115:    case LONG_PUSH_PHASE:
       48:  116:        handle_long_push_phase(BUTTON);
       48:  116-block  0
       48:  117:        break;
       48:  118:    case LONG_PUSH_NO_REPETITION_PHASE:
       48:  119:        handle_long_push_no_repetition_phase(BUTTON);
       48:  119-block  0
       48:  120:        break;
        -:  121:    }
     2520:  122:}
     1008:  123:static void handle_push_debouncing(PUSHBUTTON_TypDef *BUTTON)
        -:  124:{
     1008:  125:    if ((BUTTON->input_state) == PUSHED)
     1008:  125-block  0
        -:  126:    {
      642:  127:        if ((BUTTON->deb_rep_timer) == 0)
      642:  127-block  0
        -:  128:        {
       30:  129:            BUTTON->pushbutton_state_machine = SHORT_PUSH_PHASE;
       30:  130:            BUTTON->deb_rep_timer = PUSHBUTTON_SHORT_PUSH_TIME_MAX;
       30:  130-block  0
        -:  131:        }
        -:  132:    }
        -:  133:    else
        -:  134:    {
      366:  135:        BUTTON->pushbutton_state_machine = BUTTON_RELEASED;
      366:  135-block  0
        -:  136:    }
     1008:  137:}
       48:  138:static void handle_long_push_no_repetition_phase(PUSHBUTTON_TypDef *BUTTON)
        -:  139:{
       48:  140:    if ((BUTTON->input_state) == RELEASED)
       48:  140-block  0
        -:  141:    {
        6:  142:        BUTTON->pushbutton_state_machine = BUTTON_RELEASED;
        6:  142-block  0
        -:  143:    }
        -:  144:    else
        -:  145:    {
       42:  146:        BUTTON->pushbutton_state_machine = LONG_PUSH_NO_REPETITION_PHASE;
       42:  146-block  0
        -:  147:    }
       48:  148:}
        -:  149:
       48:  150:static void handle_long_push_phase(PUSHBUTTON_TypDef *BUTTON)
        -:  151:{
       48:  152:    if ((BUTTON->input_state) == PUSHED)
       48:  152-block  0
        -:  153:    {
       42:  154:        if ((BUTTON->deb_rep_timer) == 0)
       42:  154-block  0
        -:  155:        {
        6:  156:            execute_push_callback(BUTTON);
        6:  156-block  0
        6:  157:            BUTTON->deb_rep_timer = PUSHBUTTON_CONTINUOUS_REPETITION_TIME;
        -:  158:        }
        -:  159:    }
        -:  160:    else
        -:  161:    {
        6:  162:        BUTTON->deb_rep_timer = PUSHBUTTON_DEBOUNCE_TIME;
        6:  163:        BUTTON->pushbutton_state_machine = BUTTON_RELEASED;
        6:  163-block  0
        -:  164:    }
       48:  165:}
        -:  166:
      168:  167:static void handle_short_push_phase(PUSHBUTTON_TypDef *BUTTON)
        -:  168:{
      168:  169:    if ((BUTTON->input_state) == PUSHED)
      168:  169-block  0
        -:  170:    {
      150:  171:        handle_short_push_phase_pin_pushed(BUTTON);
      150:  171-block  0
        -:  172:    }
        -:  173:    else
        -:  174:    {
       18:  175:        handle_short_push_phase_pin_released(BUTTON);
       18:  175-block  0
        -:  176:    }
      168:  177:}
        -:  178:
      150:  179:static void handle_short_push_phase_pin_pushed(PUSHBUTTON_TypDef *BUTTON)
        -:  180:{
      150:  181:    if ((BUTTON->deb_rep_timer) == 0)
      150:  181-block  0
        -:  182:    {
       12:  183:        execute_push_callback(BUTTON);
       12:  183-block  0
        -:  184:
       12:  185:        if (BUTTON->repetition == REPETITION_ON)
        -:  186:        {
        6:  187:            BUTTON->pushbutton_state_machine = LONG_PUSH_PHASE;
        6:  188:            BUTTON->deb_rep_timer = PUSHBUTTON_FIRST_REPETITION_TIME;
        6:  188-block  0
        -:  189:        }
        -:  190:        else
        -:  191:        {
        6:  192:            BUTTON->pushbutton_state_machine = LONG_PUSH_NO_REPETITION_PHASE;
        6:  192-block  0
        -:  193:        }
        -:  194:    }
      150:  195:}
        -:  196:
       18:  197:static void handle_short_push_phase_pin_released(PUSHBUTTON_TypDef *BUTTON)
        -:  198:{
       18:  199:    execute_release_callback(BUTTON);
       18:  199-block  0
       18:  200:    BUTTON->deb_rep_timer = PUSHBUTTON_DEBOUNCE_TIME;
       18:  201:    BUTTON->pushbutton_state_machine = BUTTON_RELEASED;
       18:  202:}
        -:  203:
       54:  204:static void execute_push_callback(PUSHBUTTON_TypDef *BUTTON)
        -:  205:{
       54:  206:    if (BUTTON->push_callback != NULL)
       54:  206-block  0
        -:  207:    {
       54:  208:        BUTTON->push_callback(); // push callback to instancja gdzie trzeba zaerejsrować long push
       54:  208-block  0
        -:  209:    }
       54:  210:}
        -:  211:
       24:  212:static void execute_release_callback(PUSHBUTTON_TypDef *BUTTON)
        -:  213:{
       24:  214:    if (BUTTON->release_callback != NULL)
       24:  214-block  0
        -:  215:    {
       24:  216:        BUTTON->release_callback(); // push callback to instancja gdzie trzeba zaerejsrować long push
       24:  216-block  0
        -:  217:    }
       24:  218:}
        -:  219:/**
        -:  220: * @brief Initializes pushbuttons.
        -:  221: *
        -:  222: * This function initializes pushbuttons by obtaining GPIO interfaces,
        -:  223: * calling their initialization functions, and setting up the necessary configurations.
        -:  224: *
        -:  225: * The initialization includes:
        -:  226: * - Retrieving GPIO interfaces for PUSHBUTTON.
        -:  227: * - Calling the initialization function for each pushbutton through the obtained GPIO interfaces.
        -:  228: * - Setting the initial state of the state machines for PUSHBUTTON to BUTTON_RELEASED.
        -:  229: *
        -:  230: * @param BUTTON Pointer to the pushbutton structure to initialize.
        -:  231: * @param PB_repetition_mode The repetition mode for the pushbutton ::PB_repetition_t.
        -:  232: * @param PB_triger_mode The trigger mode for the pushbutton events ::PB_trigger_mode_t.
        -:  233: * @param PB_get_driver_interface_adr_callback Callback function to obtain GPIO interface address.
        -:  234: *
        -:  235: *
        -:  236: */
      120:  237:void init_pushbutton(PUSHBUTTON_TypDef *BUTTON,
        -:  238:                     const PB_repetition_t PB_repetition_mode,
        -:  239:                     const PB_trigger_mode_t PB_triger_mode,
        -:  240:                     const PB_GPIO_interface_get_callback PB_get_driver_interface_adr_callback)
        -:  241:{
      120:  242:    BUTTON->GPIO_interface = PB_get_driver_interface_adr_callback();
      120:  242-block  0
        -:  243:
      120:  244:    BUTTON->GPIO_interface->GPIO_init();
      120:  245:    BUTTON->repetition = PB_repetition_mode;
      120:  246:    BUTTON->trigger_mode = PB_triger_mode;
        -:  247:
        -:  248:    // init other parameters of the structure to default init value
      120:  249:    BUTTON->deb_rep_timer = 0;
      120:  250:    BUTTON->pushbutton_state_machine = BUTTON_RELEASED;
      120:  251:    BUTTON->input_state = UNKNOWN;
      120:  252:    BUTTON->REPETITION_STATUS_FLAG = REPETITION_INACTIVE;
      120:  253:    BUTTON->push_callback = NULL;
      120:  254:    BUTTON->release_callback = NULL;
      120:  255:}
        -:  256:
        -:  257:/**
        -:  258: * @brief Checks the state of a pushbutton and performs debouncing based on the trigger mode.
        -:  259: *
        -:  260: * This function updates the input state of the specified pushbutton, then determines the trigger mode
        -:  261: * and invokes the corresponding debouncing function. The debouncing process ensures reliable detection
        -:  262: * of pushbutton events, such as push, release, short push, or long push, based on the configured trigger mode.
        -:  263: *
        -:  264: * @param BUTTON The pushbutton structure to check and debounce.
        -:  265: *
        -:  266: * @note Before calling this function, ensure that the pushbutton has been properly initialized using the
        -:  267: * @ref init_pushbutton function.
        -:  268: *
        -:  269: * @see init_pushbutton, update_pushbutton_input_state, debounce_pushbutton_push_state,
        -:  270: * debounce_pushbutton_release_state, debounce_pushbutton_short_push_long_push_state
        -:  271: */
     3534:  272:void check_pushbutton(PUSHBUTTON_TypDef *BUTTON)
        -:  273:{
     3534:  274:    update_pushbutton_input_state(BUTTON);
     3534:  274-block  0
     3534:  275:    switch (BUTTON->trigger_mode)
        -:  276:    {
      540:  277:    case TRIGGER_ON_PUSH:
      540:  278:        debounce_pushbutton_push_state(BUTTON);
      540:  278-block  0
      540:  279:        break;
      474:  280:    case TRIGGER_ON_RELEASE:
      474:  281:        debounce_pushbutton_release_state(BUTTON);
      474:  281-block  0
      474:  282:        break;
     2520:  283:    default:
     2520:  284:        debounce_pushbutton_short_push_long_push_state(BUTTON);
     2520:  284-block  0
     2520:  285:        break;
        -:  286:    }
     3534:  287:}
        -:  288:
        -:  289:/**
        -:  290: * @brief Registers a callback function to be called on pushbutton press.
        -:  291: *
        -:  292: * This function associates a callback function with the specified pushbutton,
        -:  293: * to be executed when the pushbutton is pressed. The callback is triggered
        -:  294: * by changes in the pushbutton state from released to pressed.
        -:  295: *
        -:  296: * @param button_name The name of the pushbutton to register the callback for. Use values from #pushbutton_name_t
        -:  297: * enumeration.
        -:  298: * @param callback_on_push The callback function to be executed on push.
        -:  299: *
        -:  300: * @note If the pushbutton is not registered, this function has no effect.
        -:  301: *
        -:  302: * @warning Avoid lengthy operations or blocking code in the callback function, as it may impact the responsiveness
        -:  303: * of the system.
        -:  304: */
       20:  305:void register_button_push_callback(PUSHBUTTON_TypDef *BUTTON, PB_callback_t callback_on_push)
        -:  306:{
       20:  307:    BUTTON->push_callback = callback_on_push;
       20:  308:}
        -:  309:
        -:  310:/**
        -:  311: * @brief Registers a callback function to be called on pushbutton release.
        -:  312: *
        -:  313: * This function associates a callback function with the specified pushbutton,
        -:  314: * to be executed when the pushbutton is released. The callback is triggered by
        -:  315: * changes in the pushbutton state from pressed to released.
        -:  316: *
        -:  317: * @param button_name The name of the pushbutton to register the release callback for. Use values from
        -:  318: * #pushbutton_name_t enumeration.
        -:  319: * @param callback_on_button_release The callback function to be executed on pushbutton release.
        -:  320: *
        -:  321: * @note If the pushbutton is not registered, this function has no effect.
        -:  322: *
        -:  323: * @warning Avoid lengthy operations or blocking code in the release callback function, as it may impact the
        -:  324: * responsiveness of the system.
        -:  325: */
       10:  326:void register_button_release_callback(PUSHBUTTON_TypDef *BUTTON, PB_callback_t callback_on_button_release)
        -:  327:{
       10:  328:    BUTTON->release_callback = callback_on_button_release;
       10:  329:}
        -:  330:
        -:  331:/**
        -:  332: * @brief Registers callback functions for short push and long push events on a pushbutton.
        -:  333: *
        -:  334: * This function associates callback functions with the specified pushbutton,
        -:  335: * to be executed when short push and long push events occur. The short push callback
        -:  336: * is triggered when the pushbutton is released quickly, and the long push callback is
        -:  337: * triggered when the pushbutton is held down for an extended period.
        -:  338: *
        -:  339: * @param button_name The name of the pushbutton to register the callbacks for. Use values from #pushbutton_name_t
        -:  340: * enumeration.
        -:  341: * @param callback_on_short_push The callback function to be executed on a short push event.
        -:  342: * @param callback_on_long_push The callback function to be executed on a long push event.
        -:  343: *
        -:  344: * @note If the pushbutton is not registered, this function has no effect.
        -:  345: *
        -:  346: * @warning Avoid lengthy operations or blocking code in the callback functions, as it may impact the
        -:  347: * responsiveness of the system.
        -:  348: */
       36:  349:void register_button_short_push_long_push_callbacks(PUSHBUTTON_TypDef *BUTTON, PB_callback_t callback_on_short_push, PB_callback_t callback_on_long_push)
        -:  350:{
       36:  351:    BUTTON->release_callback = callback_on_short_push;
       36:  352:    BUTTON->push_callback = callback_on_long_push;
       36:  353:}
        -:  354:
        -:  355:/**
        -:  356: * @brief Enables pushbutton repetition.
        -:  357: *
        -:  358: * This function enables pushbutton repetition for the specified pushbutton.
        -:  359: *
        -:  360: * @param button_name The name of the pushbutton to enable repetition for. Use values from #pushbutton_name_t
        -:  361: * enumeration.
        -:  362: *
        -:  363: * @note If the pushbutton is not registered, this function has no effect.
        -:  364: */
       18:  365:void enable_pusbutton_repetition(PUSHBUTTON_TypDef *BUTTON)
        -:  366:{
       18:  367:    BUTTON->repetition = REPETITION_ON;
       18:  368:}
        -:  369:
        -:  370:/**
        -:  371: * @brief Disables pushbutton repetition.
        -:  372: *
        -:  373: * This function disables pushbutton repetition for the specified pushbutton.
        -:  374: *
        -:  375: * @param button_name The name of the pushbutton to disable repetition for. Use values from #pushbutton_name_t
        -:  376: * enumeration.
        -:  377: *
        -:  378: * @note If the pushbutton is not registered, this function has no effect.
        -:  379: */
       38:  380:void disable_pusbutton_repetition(PUSHBUTTON_TypDef *BUTTON)
        -:  381:{
       38:  382:    BUTTON->repetition = REPETITION_OFF;
       38:  383:}
        -:  384:
        -:  385:/**
        -:  386: * @brief Decrements the debounce and repetition timer of a pushbutton.
        -:  387: *
        -:  388: * This function decrements the debounce and repetition timer of the specified pushbutton
        -:  389: * if the pushbutton is valid and the timer is non-zero. This is typically used in the
        -:  390: * context of pushbutton debouncing and repetition control.
        -:  391: *
        -:  392: * @param button_name The name of the pushbutton to decrement the timer for. Use values from #pushbutton_name_t
        -:  393: * enumeration.
        -:  394: *
        -:  395: * @note Make sure to register the pushbutton with the system before using this function.
        -:  396: * The pushbutton state will be updated based on the specified repetition type.
        -:  397: * If the pushbutton is not registered or the timer is already at zero, this function has no effect.
        -:  398: * It is the responsibility of the caller to manage the timing of this function appropriately.
        -:  399: */
    69750:  400:void dec_pushbutton_deb_rep_timer(PUSHBUTTON_TypDef *BUTTON)
        -:  401:{
    69750:  402:    BUTTON->deb_rep_timer--;
    69750:  403:}
